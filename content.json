{"pages":[],"posts":[{"title":"20春随想","text":"这篇文章 现在是2020劳动节，写点东西来追忆过往。 缓考和实习 缓考和实习，是自二月开始的近90天里我生活的主旋律。 一边是不愿意的放弃的保研资格所以被三门虚无缥缈的缓考考试牵制，一边是希望能够找到大厂的暑期实习所以需要在短期内快速提升算法水平应付面试。为了能够顺利在缓考中拿到高分，复习自然是必不可少，但是考虑到完全是面向考试学习，这种复习成果有效期往往不超一周。 可好巧不巧的是，今年疫情缘故导致缓考时间无法确定，结果就只能一遍又一遍的复习以便做好可以随时进行考试的准备。复习过程则相当简单粗暴，刷课后题，刷例题。实际上复习后期，我只需要三天便可以将一门课的全部课后题和例题全部完成一遍。 可是我任然无法安心，依旧会因为一两小时的娱乐而懊悔不已—，因为我完全不知道这考试究极有多难，到底会出什么样的题型，一切都是未知数，都不可预知。以往在学校的时候，可以通过种种渠道获取一些“假卷子”，但总有时能发现宝藏，找到那么一两张有参考价值的试卷，能够成功分析出考试易出题型和整体难度系数。相比于难度系数，题型则更为致命的，对于某些知识点的巧妙用法被加以修饰出成伪装好的题目，除非是对课程中的知识了熟于心，不然题题都是初见杀。明明都是那么熟悉的字词，但却无处下叉。 事实是，我过饱和复习了，如果说我是为了10分难度的考试去复习，那么最终考试的难度可能不到6分。在后期寻找各类试卷时，便以初见端倪，很多考点都是浅尝则指或是因为分值限制而不见天日。 即便如此，我依旧没有放松，而这绝非褒义。你会强迫自己去利用醒着的每一分钟，不接受一分一秒的娱乐。吃饭，复习，睡觉，一遍又一遍的循环，无所谓天明和夜黑，这种状态绝非一个正常人应该有的心理状态。你会因为自己的疏忽而怨恨自己，会因为丝毫的错误而惩罚自己。一旦停下，就开始一点一滴的审查自己的过去，分析自己的行为，如同特务审问间谍一般，而结论往往是“不够好”、“太糟糕”。 这种状态一直持续到缓考真正结束，没了压力，我却无法适从，对于休闲我感到内疚，对于娱乐我却手足无措。好在考试成绩还行，只能说没有全部白给，仅此而已。 实习，更多的是无头苍蝇式的准备。不同于缓考目标明确，我们全然不了解面试官会看重什么，面试流程中会如何对我们进行评价。 最后只能抱着不亏的想法开始刷算法题，毕竟绝大多数面试流程都会有撕题环节，而这是我的软肋。无论是嵌入式系统开发还是进行分布式网络开发，对于常规的算法的使用是少之又少。在我开始准备实习之前，我的算法水平可能还停留在大一吧，这是很无奈的事实，也是和英语一样，我没有做好的地方。 总之我开始刷题，前前后后断断续续的大概用了三周时间刷完了leetcode top200，随后极为功利地开始刷《剑指offer》，大概也做了三遍左右，最后是把题解背的滚瓜烂熟，估计拿a4纸去默写可能也没啥问题了。想来也是好笑，没想到一本单词书能背一个学期的我，也能在短期利益的驱使下展现出如此强大的记忆能力。 不过有趣的是，在面试过程中手撕题目的岗位都因为其他原因，比如实习时间过长，岗位不匹配等等，最终不了了之，而最后拿到offer的岗位的面试却都是从头到尾没有问及一般的算法题，最多也只是要求描述流程或是其中的思想。 现在回首过去三个月，就结果来说，是成功的，但是若说生活质量，可能在我大学三年中糟糕程度无出其右。 抉择 肯定会有人说我矫情，或者优柔寡断，我认，这就是事实。同时拿到了腾讯和网易互娱的Offer，两者岗位又都是技术研发，就一般来说，毫无疑问腾讯夺筹。但网易呢？确实，一般来说整个平台的水平是不如腾讯的，可若是精确到某个特定的部门，我想就还得从长计议了。 但让我烦恼的并非公司技术水平，单纯只是因为加班。网易不加班，但是腾讯名气大，就这么简单。 平心而论，我选择网易，可是我也知道作为保研党的我，公司的名气比实习期间的项目更为重要，毕竟仅仅两个月的项目很难代表你当时的水平，但是你能进入某个部门则可以认为是对你的能力的肯定。 再经过三天的考虑和权衡之后，我赶在ddl前两小时做出了最终的决定，尽管这样我可能后悔一年，尽管这样可能会带来巨大风险，尽管这样会让我没有退路，我还是选择：我全都要。 没错！今年疫情缘故，导致考试推迟，故早在六月初就一身轻松，赶赴深圳入职腾讯；在经过六七两个月的实习后再前往广州，入职网易，中途请假参加保研答辩和考试，随后于十月中旬离职返校，完成课程设计和行政论文，总计翘课６周，中途需要参加两门线下考试，一次线下答辩。就是这么刺激，玩的就是心跳。 当然这都是理想情况，网易那边能否顺利入职，腾讯能否再仅仅9周实习后拿到证明，中途能否在一周假期内完成考试和答辩，能否顺利联系导师。自然，我是在把我往绝路上推，但是实在不济就只能当一把“渣男”甩网易了。","link":"/2020/05/02/20-spring-thought/"},{"title":"ASC19后记","text":"本来打算是大二下的暑假把这篇博客补完,拖来拖去,竟已到了20年春.这大半年里,发生了太多,我也试图去改变自己,至于我是否还是真的变了,我不知道,但至少已经不是去年今日的心态了.到也说不上物是人非,可是看着这篇写于当时的开头,羡慕与憧憬之情油然而生.无忧无虑的生活终是一场空想,当下所享受的一切必然都欲承其后果.但不论如何,还是打算把这篇博客补完,就当是怀忆当初,以明我志. ASC192019年的ASC比赛,去年我科未进决赛,今年虽不至于如此,但现场还是状况频出:ib爆破,cuda爆破,mpi爆破,甚至内存条爆破(官方白皮书给的说明有误),但总的来说,食堂很好吃,茶点很美味,室内很舒适,网很快,服务很技术,就是有点吵,体验很不错,下次有需要还会来. 但是现在再提比赛的事已经毫无意义.比赛本身并没有太多值得我们去记忆的,比赛过程对我而言也并不是那么的”刻骨铭心”,现在想着,也不好说是悔恨当初,还是嫉妒当时的自己,居然还能如此的无忧无虑,崇尚享乐主义.这篇文章与其说是后记,不如说是游记,但想到可能还会掺杂着一些技术,故还是叫做后记吧,省的目的不纯,怀疑初心. 大连理工坐标大连(废话),离海比较近(虽然还是没去海边),旧楼很多,新楼零星其中,人奇少无比.第一天整天见到的大连理工的人甚至不超过20个,以及我们住的酒店居然是学校宿舍的一部分,有被动客房服务,没给扫把,体验很差,唯独网络质量尚可.既然这比赛是在大连理工举办的,那这后记必然得从这里讲起.大连理工于我看来,是最像我心中的大学的地方.没有人流,没有噪音,甚至毫无生机,新式的建筑和残破的砖房并存.在这里,现代和过去交融,人和知识共舞,人无需保持作为生物的特性,我们只是学者,我们只是贪婪的渴求知识,所谓生机盎然与我无关.然而那时的我可没有此等心境,想的也大多只是新手机买什么吧,甚是有趣.但现在回想起来,大连理工,就仿佛只存在于故事之中.回到现实,大连理工的食堂太少了,不适合我生存. 大连四月份的大连气温尚低，还未进入旅游季节，哪怕是海边也没有多少人，双目可见之处都是一些跳着广场舞的大妈。景区商场也是冷冷清清，找了家汉堡王躲进去，狼吞虎咽一波算是解决了晚饭。 比赛现场比赛场地设置在大连理工的体育馆,很有想法,效果也确实不错,至少不会像16年那么喧嚣,但也远谈不上舒适.比赛装机过程还算顺利,毕竟所有参赛队伍都被赛事方的水货显示器坑了一波,最后使用主板的vnc功能才算是有了终端输出.之后便是无尽的恐惧,ib驱动无法工作,但是解决了,cuda无法正常运行,也算是解决了,mpi无法在ib上工作,我们慌了,真的慌了,但是也无能为力了.真要说有什么教训,买好插线板,买好有线网适配器,最好再带个路由器,以及提前演练装机过程.但想在想想,这一切真的会有用么?谁都说不定.这是一场超算的比赛,绝非仅仅只是代码优化的比赛,运维的重要,超乎想象. 颁奖就如同你预想的那般无趣，大概就是一堆大佬去台上巴拉巴拉的讲了许多，然后各个获奖代表队上台领奖.我最后也没有参加赛事方的晚宴，而是赶着最后一个晚上去大连的海边转了转。 旅途来往大连都是乘坐飞机出行,设备带的齐全,安检就越是麻烦.把包里面的电子设备挨个逃出来,再仔细的堆放好,稍有不慎,这背包链子就算是拉不上了.好在平日里这种场景时有发生,我已是轻车熟路.此外还有什么需要说的么?没了吧,总觉得空虚,那就再补点吧.路途的印象和时间成正比,当然也和目的地密切相关.我记忆中最深刻的路途,必然是前往西宁的列车了,25个小时,穿越半个中国,海报提升3000m,如梦如幻.飞机则是另一种极端,试图尽最大可能降低你的回忆,当然这也符合它的目的,高效舒适的将乘客运抵目的地才是第一准则.哦,我们运气比较好,回程的时候是个大晴天,在飞机上看清了大连和海,很幼稚,但也很有仪式感. 后记这个博客还是得写的,看着孤零零的两篇stm32的文章,我也不知道我的大一大二是如何度过的了,可能我得好好回想一下,才能补全,之后还是写下来,记录一下比较好.However, i think there’s not many things need to put into my heart. In the asc19, in my opinion, i’not playing an important role, more like touching fish and having some fabulous fun during that three monthes.I am used to believing having a relaxing life and a not much heavy work, or “work for life” instead of “life for work”. Only that days.","link":"/2019/04/25/ASC19-journal/"},{"title":"Arch Linux Installation","text":"ddl是检验生产力的唯一标准 本次的安装是在VBox虚拟机环境下进行，物理机可能会有所出入，一切还请以Arch Linux官方wiki为准。 安装准备安装介质 到 https://www.archlinux.org/download/ 页面下载最新的iso镜像文件； 使用dd（linux下）或者rufus（Windows下）制造安装介质。 磁盘准备至少10GB的空闲空间，如果想日常使用，则建议至少50GB，否则连大的开发环境都不便于配置。 BIOS设置在BIOS中将启动项设置我们制作的安装u盘，对于虚拟机安装而言，则为将启动项设为加载了镜像文件的虚拟光驱。 安装过程进入 Live CD 系统 做好安装准备后，启动便会看到如下界面： 选择第一项进入 Live CD 系统，屏幕显示如下内容：加载完成后，将进入一有命令提示符的界面：这时便成功启动了 Live CD 系统，接下来将 Arch Linux 安装到硬盘上 联网Arch的安装需要通过互联网来下载组件，故在开始正式的安装前我们要先联网。 如果为有线网，并且路由器开启DHCP服务的话，则执行：1dhcpcd 如果为无线网。则执行：1wifi-menu 这是一个命令行下的wifi管理工具，有字符形式的图形界面。 使用类似以下的命令来检测网络是否连接：1ping www.baidu.com 对于部分机器，可能存在无线网卡驱动兼容性问题，但是有线网一般是可以使用的，可以插网线装好系统后再慢慢解决驱动问题。 更新系统时间执行以下命令以启用ntp服务来自动同步系统时间： 1timedatectl set-ntp true 分区与格式化首先检测现有的分区表，执行以下命令： 1fdisk -l 可得到如下输出：可以看到在这块硬盘上没有分区表的存在。 考虑到虚拟机采用BIOS/MBR的引导方式，故我们使用MBR分区表以便于操作。 输入命令：1cfdisk /dev/sdx （将sdx替换之前看到的磁盘） 选择“dos”分区方式这样我们便在磁盘上创建了一个MBR分区表，当然所有的修改在确认写入前都是没有改动实际的磁盘数据的。随后便会看到以下界面：可以再次看到，这块磁盘上没有分区存在。 使用上下左右键来移动下面的光标，选择“NEW”来新建一个分区。我们新建一个占据全部空间的“Linux File System”类型的主分区，注意是主分区，即primal partition，对于MBR分区表，只有主分区是可以作为启动引导分区的。随后再次移动光标，选择下方的“Bootable”，将该分区设置为可引导分区。最终效果如图： 确认无误后，移动光标选择“Write”，将我们所有的改动写入到实际的磁盘上，一旦执行了这步之后就回不了头了，所以需要多次确认后再执行，我们这次是一个空硬盘，所以怎么折腾都是可以的。最终退出该程序，分区结果如下图所示： 输入以下命令来格式化刚刚创建的分区:1mkfs.ext4 /dev/sdxY (将sdxY替换为刚刚创建的分区) 挂载分区执行以下命令来挂载将刚刚创建的分区挂载：1mount /dev/sdxY /mnt (将sdxY替换为刚刚创建的分区) 安装基本软件包接下来要开始字面意义上的安装过程了，将要把Archlinux安装到磁盘上，注意，这个过程需要保持互联网的接入。执行以下命令开始安装：1pacstrap /mnt base base-devel 命令提示行出现以下画面，等待安装结束、命令提示符重新出现即可进行下一步。 生成fstab安装过程中我们是手动挂载了根目录，但是不可能每次开机都进行一次挂载操作，因此我们需要生成自动挂载分区的fstab文件。执行以下命令： 1genfstab -L /mnt &gt;&gt; /mnt/etc/fstab 使用cat命令将该文件输出到屏幕，如下图所示：可以看到 /dev/sda1被挂载到根目录。 chroot到这一步，我们需要把操作权交给我们刚刚安装到磁盘上的操作系统，执行这步后，所以的操作都是在新装的系统进行的。执行以下命令： 1arch-chroot /mnt 设置时区依次执行以下命令： 12ln -sf /usr/share/zoneinfo/Asis/Shanghai /etc/localtimehwclocl --systohc 如下图所示： 安装必要的软件包通过 pacman 安装vim，等接下来需要使用的软件包。执行以下命令： 1pacman -S vim 设置语言数据 首先使用vim打开 /etc/locale.gen 文件，并将zh_CN.UTF-8 UTF-8、zh_HK.UTF-8 UTF-8、zh_TW.UTF-8 UTF-8、en_US.UTF-8 UTF-8四行前的注释符号去除，然后保存退出。如下图所示：然后执行：1locale-gen 配置语言首选项使用vim打开/etc/locale.conf文件在文件第一行输入：1LANG=en_US.UTF-8 然后保存退出。 设置主机名 使用vim打开/etc/hostname文件，在第一行输入你想要的主机名，保存并退出。 使用vim打开/etc/hosts文件，在文件末尾添加如下三行：123127.0.0.1 localhost::1 localhost127.0.1.1 yourhostname (替换为你之前设定的主机名) 保存并退出。 安装intel-ucode对于intel CPU，使用pacman安装： 1pacman -S intel-ucode 安装bootloader 我们使用grub作为bootloader： 安装grub包：1pacman -S grub 部署grub到引导扇区：1grub-install --target=i386-pc /dev/sdx （将sdx替换之前看到的磁盘） 生成grub配置文件：1grub-mkconfig -o /boot/grub/grub.cfg 至此Bootloader的安装便结束了，建议安装后检查grub.cfg文件的生成是否正确，至于如何读懂该文件，可以参照Archlinux官方wiki。 修改root密码执行以下命令： 1passwd 依照提示设置密码，注意密码输入无回显。 重启接下来到了最为激动人心的环节，之前的所有努力与付出都将在此时得到检验，成败再次一举。执行如下命令： 12exitreboot 如果是物理机，则在关机后拔出u盘，如果是虚拟机，则将虚拟光驱弹出即可。如果一切顺利，你将看到如下画面，并可以使用root用户进行登陆： 配置虚拟内存我们采用文件形式的交换空间，便于我们的管理。先分配一块空间(512M大小为例)： 1fallocate -l 512M /swapfile 然后更改该空间的权限: 1chmod 600 /swapfile 设置为交换文件： 1mkswap /swapfile 启用交换文件： 1swapon /swapfile 最后还需要修改fstab文件来实现自动启用交换文件，如下图所示进行修改： 新建用户我们的日常操作不可能以root用户的身份进行，这样是极不安全的。因此我们新建一个权限较低的用户日常使用。 1useradd -m -G wheel username 我们新建了一个名为username的用户，并将它加入了wheel组，同时也为它在/home目录下新建了同名的家目录。 配置sudo首先使用pacman安装sudo软件包： 1pacman -S sudo 当然，在使用pacman之前，你需要先连接网络，具体操作与 Live CD 系统的操作一致。然后使用visudo编辑sudo的配置文件：将 1# %wheel ALL=(ALL) ALL 前的注释去除，退出保存即可。配置好sudo以后，我们再次重启电脑，并且以新建的用户登陆系统，并且记得需要重新进行联网操作。 安装图形化界面我使用了xfce作为本次安装的桌面管理器，其他桌面的安装大同小异。直接使用pacman安装图形界面和桌面的软件包： 1sudo pacman -S xorg xfce sddm 同时我们需要安装桌面使用的网络连接管理软件networkmanager: 1sudo pacman -S networkmanager 随后安装完毕后，我们需要启用我们刚刚安装的sddm桌面管理器，以方便我们在开机后进行登陆并选择使用的桌面。使用systemctl来管理系统服务： 1sudo systemctl enable sddm 同时我们需要提前配置网络，将自带的netctl换为networkmanager： 12sudo systemctl disable netctlsudo systemctl enable NetworkManger 然后重启，如果一切顺利，你将成功看到桌面管理器界面，输入用户名和密码后便可以进入桌面环境。 最后 依照惯例：","link":"/2019/07/06/Arch-Linux-Installation/"},{"title":"使用 Travis CI 自动部署 HEXO 博客到 GitHub","text":"本来只是想给博客换个主题（旧的主题引用的某个js源炸了，懒得改代码，于是决定重新换个主题），但是翻着翻着就发现了个叫 Tarvis CI 的好玩的网站，（突然感觉自己弱爆了，以前居然连这种东西都不知道），于是打算折腾一通，试一试感觉如何。最终的结论是，效率提升≈0，逼格提升≈1000000（穷人，只有一台电脑，不存在环境问题）。 无论如何，写篇博客记录一下吧（理论上这篇博客也是 Tarvis CI 托管生成的）。 准备阶段Tarvis你要用 Tarvis ，好歹得有个账号吧，所幸 Tarvis 和 GitHub 关系比较暧昧特殊，可以直接用GitHub账号登陆；（请猛击那个Sign in with GayHub）之后就需要选择自动生成哪些repo；在Tarvis的操作目前到此为止，但我们之后还是要回来的。 GitHub仓库：首先先把博客的 repo clone 到本地来，然后签出一个新的分支（叫 dev 还是什么其他看个人兴趣，我的叫 hexo ，这个就不放图了啊），这个分支用于保存博客的 raw 文件，渲染之后再将其push到master分支，这样的话不需要新开一个 repo 。 然后，重头戏，把这个 branch 里的文件给删！光！光！然后再把本地用于生成博客的文件拷贝进来，然后push（别忘记创建远程分支）。 之后就应该是这样 master分支用于存放 渲染完的博客网页文件 。 hexo分支用于存放 用于渲染博客的文件 。 密钥：然后我们还需要一个让 Tarvis 的服务器能够向我们在 GitHub 上 Push 代码的凭证。但是问题在于，我们博客的仓库是开源的，如果将密钥或是其他的什么直接明文存储，呵呵。。。 所以我们需要一个加密存储的方式，Tarvis 上可用的有两种： 使用 ssh key 使用 Tarvis 的环境变量来存储 GitHub Token 我这里选择了第二种（一般来说第一种安全些，各位可以从网上参照一下）。 在个人设置里面， 新建一个新的个人 token ， token 需要给予 repo 的控制权限，记得在创建完成后复制生成的 token ，之后是无法查询到这个 token 的数值的。 然后我们需要重新回到 Tarvis , 点击你激活的那个 repo 左边的齿轮图标进入设置界面，将我们刚刚拿到的 token 设置为环境变量。 至此，准备工作彻底完毕，接下来就要开始掉头发码代码了。 具体配置“.travis.yml”请在当前本地仓库的 hexo 分支根目录下创建如章节名称的文件（注意以 “.” 开头），然后用代码编辑器打开这个文件（废话），关于这个文件的编写可以参照这篇博客：持续集成服务 Travis CI 教程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 选择使用的语言language: node_jsnode_js: stablesudo: false# 为了提速，我们在这里使用缓存来把node的package都保存下来cache: directories: - \"node_modules\"# Tarvis 给你发提醒的配置notifications: # 我们选择使用邮件 email: recipients: # 你的邮件地址 - youremail@xxx.com # 是否在成功时发生邮件 on_success: never # 是否在失败时发送邮件 on_failure: always# S: Build Lifecycleinstall: - npm installbefore_script: - export TZ='Asia/Shanghai' - chmod +x _travis.sh# hexo标准操作，注意没有\"hexo d\"，即不进行部署script: - hexo clean &amp;&amp; hexo gafter_success:# 没有这个文件？有才见了鬼，这个文件我们待会手写!after_script: - ./_travis.sh# E: Build LifeCycle# 选择进行操作的分支，即 Tarvis 需要监测和处理的分支，也可以使用黑白名单，用法请自行Googlebranches: only: - hexo# 设置环境变量，注意这里的环境变量是没有加密的env: global: # 你的GitHub地址 - GH_REF: github.com/milkybird98/milkybird98.github.io.git 博主本人也是自行摸索+借鉴，有可能在设置上存在问题，还请指出（可以在GitHub上留个issue之类的）。 “_travis.sh”在 “.tarvis.yml” 里面我们没有执行 “hexo d” 命令，因为我们需要手动部署。（这一段是直接使用的shenliyang大大的代码，在此感谢shenliyang大大） Ps. 貌似可以用 hexo 的 deploy，各位可以去研究一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#--------------------------------------------# !/bin/bash# author：shenliyang# website：https://github.com/shenliyang# slogan：梦想还是要有的，万一实现了呢。#--------------------------------------------#定义时间time=`date +%Y-%m-%d\\ %H:%M:%S`#执行成功function success(){ echo \"success\"}#执行失败function failure(){ echo \"failure\"}#默认执行function default(){ git clone https://${GH_REF} .deploy_git cd .deploy_git git checkout master cd ../ mv .deploy_git/.git/ ./public/ cd ./publiccat &lt;&lt;EOF &gt;&gt; README.md部署状态 | 集成结果 | 参考值---|---|---完成时间 | $time | yyyy-mm-dd hh:mm:ss部署环境 | $TRAVIS_OS_NAME + $TRAVIS_NODE_VERSION | window \\| linux + stable部署类型 | $TRAVIS_EVENT_TYPE | push \\| pull_request \\| api \\| cron启用Sudo | $TRAVIS_SUDO | false \\| true仓库地址 | $TRAVIS_REPO_SLUG | owner_name/repo_name提交分支 | $TRAVIS_COMMIT | hash 16位提交信息 | $TRAVIS_COMMIT_MESSAGE |Job ID | $TRAVIS_JOB_ID |Job NUM | $TRAVIS_JOB_NUMBER |EOF git init # 输入你自己的GitHub的name和email git config user.name \"milkybird98\" git config user.email \"milkybird98@outlook.com\" git add . git commit -m \"Build by Travis CI\" # ${GH_TOKEN}替换为你设定的 token 的环境变量名称${xxxx}，${GH_REF}是在上一节中设定的 git push --force --quiet \"https://${GH_TOKEN}@${GH_REF}\" master:master}case $1 in \"success\") success ;; \"failure\") failure ;; *) defaultesac 至此，文件上的处理就完成了，现在只需要把 hexo 分支的代码 push 一次， Tarvis CI那边检测到 request 后就会自动去进行处理。 坑 问题：如果你出现了 build 成功但是博客打开后却是一片白，或者远程仓库里主题文件夹一片空白（一般情况是连theme文件夹都没有）； 解决：使用如下指令而非clone，将主题的仓库作为子模块使用，或者直接将主题的仓库变为普通的本地代码。 1git add submodule git://github.com/xxxxxxxxxx/xxxxxxxx.git theme/${你的主题名称}/ 问题：build 成功但是仓库的 master 分支没有变化； 解决：请确定你输入的 token 是否正确（其实根本没法确认，删掉旧的再申请个新的吧），以及权限是否正确。 Tips可以将主题 fork 一份，然后使用子模块的方式将主题加载自己的博客仓库中，并且在”.tarvis.yml”中”hexo clean &amp; hexo g”之前的加入如下指（貌似不加也可以，git 执行 “git clone” 应该是会同时下载子模块的）。123- git submodule init- git submodule update- hexo clean &amp; hexo g 这个小绿标是不是很诱人，加上去其实很简单： 首先让我们再次回到 Tarvis CI，点一下这个灰色的按钮（不用管这个的颜色，因为我们的master分支是不进行托管的，所以是灰色的）； 然后在弹出框中选择你进行处理和分支，语言选择Markdown； 复制最后的地址，将其粘贴到”_travis.sh”文件中生成README.MD的代码处,同时你也可以做一些修改，比如这是我的README.MD： 12345678910111213141516171819cat &lt;&lt;EOF &gt;&gt; README.md# Milkybird98 唯一指定blog。Stella Splendida.[![Build Status](https://travis-ci.org/milkybird98/milkybird98.github.io.svg?branch=hexo)](https://travis-ci.org/milkybird98/milkybird98.github.io)部署状态 | 集成结果 | 参考值---|---|---完成时间 | $time | yyyy-mm-dd hh:mm:ss部署环境 | $TRAVIS_OS_NAME + $TRAVIS_NODE_VERSION | window \\| linux + stable部署类型 | $TRAVIS_EVENT_TYPE | push \\| pull_request \\| api \\| cron启用Sudo | $TRAVIS_SUDO | false \\| true仓库地址 | $TRAVIS_REPO_SLUG | owner_name/repo_name提交分支 | $TRAVIS_COMMIT | hash 16位提交信息 | $TRAVIS_COMMIT_MESSAGE |Job ID | $TRAVIS_JOB_ID |Job NUM | $TRAVIS_JOB_NUMBER |EOF 结语感觉根本没啥卵用啊，只不过是从 123hexo cleanhexo ghexo d 变成了 123git add .git commit -am \"xxx\"git push 到头来还是三个指令（哭唧唧）。","link":"/2018/04/07/build-a-new-blog-via-travis/"},{"title":"STM32驱动LCD屏幕","text":"本文中使用的LCD驱动芯片为ili9341，下文中简称为驱动芯片。官方的PDF就不摆上来了，自己去这找找就行了Google。 配置 MCU为STM32F103ZE，主频72Mhz，使用Spi与驱动芯片通讯，Spi时钟频率为18Mhz。 鉴于驱动芯片可以设定显示窗口（即改写选定部分的显存数据，如将窗口设定为x=20;y=30;宽=50;高=70）,可以使用DMA来提高数据传输效率，尤其是在显示文字的过程中，可以直接将文字对于的点阵转换为一个n*n的图片，再一次性的发送给驱动芯片。 但是使用时需要注意检测前一次的DMA发送是否已经完成，否则会出现数据传输不完整的错误。 使用PB1，2引脚作为驱动芯片的DC引脚和RST引脚。 底层IO函数 驱动芯片在写入寄存器时不再明显的区分指令寄存器和显存寄存器，写入指令不在是“索引+对于寄存器的数据”，而改为“指令+[参数/数据]”的格式，简而言之，无论是修改设置还是发送图像数据，其实都是一条指令以及相应的数据。 在发送指令时，先应将DC脚拉低，在通过Spi发送两个字节的数据，随后将RS脚拉高即可。 发送数据较为简单，在指定寄存器索引后直接在Spi上传出数据即可。 同时应注意到，有些指令是没有数据的，如“开始显示画面”，有些指令的数据量则十分巨大，如“写入显存”，这也是“索引+数据”和“指令+[参数/数据]”模式最大的区别，即后者发送的指令本身的功能就不仅仅只是指定寄存器，亦可以修改某些数据。 如果需要硬重启需要将RST引脚从高电位拉低，再拉高，同时应当适当加入延时。 发送指令 12345void writeCommand(uint8_t cmd){HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_RESET);HAL_SPI_Transmit(&amp;hspi1,&amp;cmd,1,2);HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_SET);} 发送数据 123void spiWrite(uint8_t data){HAL_SPI_Transmit(&amp;hspi1,&amp;data,1,2);} 重启 12345678void lcdRestart(void){HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,GPIO_PIN_SET);HAL_Delay(100);HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,GPIO_PIN_RESET);HAL_Delay(100);HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,GPIO_PIN_SET);HAL_Delay(200);} 初始化初始化过程参见PDF，主要包括电源控制，内存访问控制和屏幕刷新相关设置的初始化（暂时先鸽了），其中伽马矫正部分需LCD屏幕供应者提供相应的参数（或者随便输一点）。 初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111writeCommand(0xEF);spiWrite(0x03);spiWrite(0x80);spiWrite(0x02);writeCommand(0xCF);spiWrite(0x00);spiWrite(0XC1);spiWrite(0X30);writeCommand(0xED);spiWrite(0x64);spiWrite(0x03);spiWrite(0X12);spiWrite(0X81);writeCommand(0xE8);spiWrite(0x85);spiWrite(0x00);spiWrite(0x78);writeCommand(0xCB);spiWrite(0x39);spiWrite(0x2C);spiWrite(0x00);spiWrite(0x34);spiWrite(0x02);writeCommand(0xF7);spiWrite(0x20);writeCommand(0xEA);spiWrite(0x00);spiWrite(0x00);writeCommand(ILI9341_PWCTR1); //Power controlspiWrite(0x23); //VRH[5:0]writeCommand(ILI9341_PWCTR2); //Power controlspiWrite(0x10); //SAP[2:0];BT[3:0]writeCommand(ILI9341_VMCTR1); //VCM controlspiWrite(0x3e);spiWrite(0x28);writeCommand(ILI9341_VMCTR2); //VCM control2spiWrite(0x86);writeCommand(ILI9341_MADCTL); //Memory Access ControlspiWrite(0x48);writeCommand(ILI9341_VSCRSADD); //Vertical scrollspiWrite(0x00);spiWrite(0x00); //ZerowriteCommand(ILI9341_PIXFMT);spiWrite(0x55);writeCommand(ILI9341_FRMCTR1);spiWrite(0x00);spiWrite(0x18);writeCommand(ILI9341_DFUNCTR); //Display Function ControlspiWrite(0x08);spiWrite(0x82);spiWrite(0x27);writeCommand(0xF2); //3Gamma Function DisablespiWrite(0x00);writeCommand(ILI9341_GAMMASET); //Gamma curve selectedspiWrite(0x01);writeCommand(ILI9341_GMCTRP1); //Set GammaspiWrite(0x0F);spiWrite(0x31);spiWrite(0x2B);spiWrite(0x0C);spiWrite(0x0E);spiWrite(0x08);spiWrite(0x4E);spiWrite(0xF1);spiWrite(0x37);spiWrite(0x07);spiWrite(0x10);spiWrite(0x03);spiWrite(0x0E);spiWrite(0x09);spiWrite(0x00);writeCommand(ILI9341_GMCTRN1); //Set GammaspiWrite(0x00);spiWrite(0x0E);spiWrite(0x14);spiWrite(0x03);spiWrite(0x11);spiWrite(0x07);spiWrite(0x31);spiWrite(0xC1);spiWrite(0x48);spiWrite(0x08);spiWrite(0x0F);spiWrite(0x0C);spiWrite(0x31);spiWrite(0x36);spiWrite(0x0F);writeCommand(ILI9341_SLPOUT); //Exit SleepHAL_Delay(120);writeCommand(ILI9341_DISPON); //Display onHAL_Delay(120); To be continued.","link":"/2018/03/04/lcd-driver/"},{"title":"Petalinux 入门指南：第一个Petalinux工程","text":"#1 Petalinux BSP 参考：homepage: https://www.xilinx.com/products/design-tools/embedded-software/petalinux-sdk.htmlug1144: https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug1144-petalinux-tools-reference-guide.pdf Petalinux 中的一个工程被称为一个BSP，BSP包含运行系统所需的所有文件，BSP的出现使得跨团队的开发变得更为便捷。自定义的Petalinux可以通过打包再交付给下一级的开发人员，使得其不需要重新配置就可以直接使用上级开发人员的产出。Xilinx和二级开发板制造商可能会提供“参考BSP”，一个由供应商开发人员打包的完整BSP，可以做到即载即用，并且这些设计可以作为用户进行进一步开发的基础。综上，有两种方法建立Petalinux工程： 下载官方的参考BSP，并创建工程 使用自行设计的硬件平台创建新的工程 #2 根据参考BSP创建工程 参考：homepage: https://www.xilinx.com/products/design-tools/embedded-software/petalinux-sdk.htmlug977: https://www.xilinx.com/support/documentation/sw_manuals/petalinux2013_10/ug977-petalinux-getting-started.pdf 你只需找到对应开发板的参考BSP包，下载载入即可。参考BSP已经预先编译好了系统和Demo，无需用户再次编译，可以直接下载至开发板或会使用QEMU进行模拟。首先请手动创建预期的工程目录，并将工作路径切换至目录中，随后加载Petalinux环境变量，然后根据BSP创建新的工程： 1$ petalinux-create -t project -s /path/to/your/bspfile.bsp -n custom-project-name 请修改命令中的BSP文件路径至实际的路径。 随后可以尝试在QEMU虚拟机中启动预编译的系统镜像： 1$ petalinux-boot --qemu --kernel 如果一切正常，你应该可以看见u-boot和kernel启动过程中的log输出，直至最后停留在登陆命令处，可以使用root账户（默认密码为”root”）登入。 #3 根据自定义硬件平台创建工程 参考：ug1144: https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug1144-petalinux-tools-reference-guide.pdf 对于绝大多数的非官方参考开发板，都需要根据设计好的硬件平台手动创建工程。 #3.1 获取硬件平台设计文件首先，你需要在Vivado中进行硬件设计，为了让Linux可以正常在zynq芯片的arm核上运行，你需要分配一定的硬件资源。根据ug1144，对于使用Petalinux的参考Linux，需要提供以下的资源： TTC模块，作为系统时钟 至少32MiB存储空间 UART模块（可选）用于输出控制台 NV存储器（可选） 以太网接口（可选） 如果要使用Microblaze等其他处理器，请参考ug1144。 在Vivado中启用并预留好相应的硬件资源、设计实现PL部分，进行综合，实现，使用“Export Hardware”功能导出Petalinux需要的硬件平台设计文件，包括用于描述硬件配置的xsa文件和保存比特流的bit文件。 #3.2 创建Petalinux工程将需要文件拷贝至期望的新Petalinux工程目录下，对于zynq芯片平台，执行如下命令： 1$ petalinux-create --type project --template zynq --name custom-project-name 你应该可以在终端上看到成功创建工程的输出信息，若是其余硬件平台请修改”template”参数。 随后需要载入之前导出的硬件设计文件，使用如下命令，Petalinux会自动在当前目录中寻找可用的硬件设计文件： 1$ petalinux-config --get-hw-description 因为是新的工程，Petalinux会自动进入配置界面，在里面我们可以配置一些系统参数，主要的配置包括：启动方式，启动存储器分区表，启动文件名称等等。请根据硬件平台的设计选择对应的u-boot和kernel启动方式，如果希望使用QEMU虚拟机进行仿真则无需修改启动选项，QEMU虚拟机将直接读取kernel镜像。退出至配置根目录，使用左右方向键移动下方功能光标，选择“Save”保存配置文件，之后退出配置界面，Petalinux会自动根据配置文件配置当前工程。配置过程需要进行文件复制，所需时间从10分钟至半小时不等，配置过程中不需要进行人工确认。 如果你需要配置kernel，比如加入硬件支持或者进行内核裁剪，请使用如下命令打开kernel配置界面： 1$ petalinux-config -c kernel 与正常的kernel配置界面并无区别（实际上就是调用了menuconfig）。 此外，还有如下配置可以进行： 12345$ petalinux-config -c u-boot#配置u-boot$ petalinux-config -c rootfs#配置rootfs #3.3 设备树配置Petalinux能够根据硬件描述文件自动地把IP外设添加至设备树中，但是对于其他的非IP外设则需要手动修改设备树以告知系统该硬件的存在。设备树文件的目录为：./subsystems/linux/configs/device-tree具体方法与常规的ARM Linux设备树修改无异，这里就不再赘述。 修改设备树后，可以使用如下命令编译设备树文件，而不进行全局编译： 1$ petalinux-build -c device-tree #3.4 编译请确保电脑的供电稳定，能够顺利访问境外服务器，磁盘上有至少20GiB的剩余空间，以及4GiB的空闲内存 在工程目录下，执行如下命令： 1$ petalinux-build Petalinux将编译u-boot，kernel以及rootfs，编译过程可能需要联网下载文件，总耗时取决于电脑配置和境外网速，从30分钟至4小时不等。 自然，你可单独编译这三个部分，具体命令如下： 12345$ petalinux-build -c u-boot$ petalinux-build -c kernel$ petalinux-build -c rootfs 编译完成后的镜像文件位于：./images/linux其中四个文件在接下来会被用到， zynq_fsbl.elf (zynq引导文件) image.ub (Linux系统镜像) u-boot.elf (u-boot引导文件) your-bitstream.bit (比特流文件) 这里可以顺便一提，zynq使用三阶段引导，分别是 rom boot loader，固化在rom中 fsbl，用于加载bitstream并启动下一阶段引导 u-boot或其他boot loader，负责arm核的初始化和系统镜像的引导。 #4 打包制作BOOT.BIN文件 参考：ug1144: https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug1144-petalinux-tools-reference-guide.pdf BOOT.BIN文件为zynq系列芯片的启动引导的标准名称，包含fsbl、uboot和比特流文件，使用sd卡或者u盘或者其他外部存储进行启动时，都需要先将引导打包成BOOT.BIN文件。 在Petalinux工程目录下，执行如下命令进行打包： 1$ petalinux-package --boot --fsbl zynq_fsbl.elf --fpga your-bitstream.bit --u-boot u-boot.elf 请根据实际情况，修改比特流文件的名称。 #5 启动系统 参考：ug1144: https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug1144-petalinux-tools-reference-guide.pdfug982: https://www.xilinx.com/support/documentation/sw_manuals/petalinux2013_10/ug982-petalinux-system-simulation.pdf #5.1 从QEMU启动系统QEMU虚拟机可以直接加载系统镜像，而不需要其他引导，具体命令如下： 1$ petalinux-boot --qemu --kernel root账户的默认密码为 root 如果想退出虚拟机，请按下 Ctrl+a*，然后按下 *x #5.2 从jtag启动系统连接至开发板串口，并将波特率设置为115200以正确读取输出，执行如下命令启动系： 1$ petalinux-boot --jtag --prebuilt 3 –prebuilt 3 意味着linux kernel。root账户的默认密码为 root 如果只需要将程序下载至开发板而不进行启动，可以执行如下命令： 123$ petalinux-boot --jtag --fpga --bitstream &lt;BITSTREAM&gt;$ petalinux-boot --jtag --u-boot$ petalinux-boot --jtag --kernel 遇到问题请优先考虑ug1144，善用目录和查找功能。","link":"/2020/05/31/petalinux-guide-2/"},{"title":"Petalinux 入门指南：Petalinux的介绍与安装","text":"#1 序Xilinx的文档一向以“烂”著称，而Petalinux有关的文档则是集大成者，如果你发现某处出现了magic command，那很可能只是在某文档的小字里面淡淡描述过。该文章系列一共有三部分，分别是Petalinux的介绍与安装，你的第一个Petalinux工程，以及Petalinux的应用开发，有关IP核的开发和设备树等涉及硬件的开发这个系列不涉及，不过可能有番外篇来讲述一下QEMU的网络配置。如果安装过程中出现某些奇怪的报错内容，还请google一下。考虑到Xilinx的服务器全部位于海外，如果你正在看着这篇文章，并试图去跟着完成Petalinux的开发，那么请现在就去开始下载。注意，下载与你所使用的硬件开发工具(如Vivado)大版本号相同的Petalinux。Petalinux本身并不复杂，许多功能也不magic，只是你不知道，Xilinx也不告诉你，我会试图分析并解释这些功能。考虑到部分内容也只是我的经验之谈，如有错误还请指正。 #2 Petalinux 101 参考：homepage: https://www.xilinx.com/products/design-tools/embedded-software/petalinux-sdk.htmlug1144: https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug1144-petalinux-tools-reference-guide.pdf 按照较为商业的说法，Petalinux是一个“解决方案”，而非Linux发行版，Petalinux为用户提供从定制内核和rootfs，编译内核和rootfs以及打包启动镜像并部署至开发板的全套功能。同时为了提升效率，Petalinux可以与类似Vivado之类的“Xilinx 硬件开发工具”配合使用，比如可以导入Vivado导出的硬件描述文件和bitstream文件构建一个PS+PL的项目。Petalinux是随着zynq等arm+fpga这类组合芯片的出现而诞生的，解决了在这类arm+fpga芯片上移植linux等等琐事。如果不使用Petalinux，用户需要手动编译kernel和u-boot，然后将编译得到的镜像在Vivado等工具中，与FSBL、bitstream手动打包成启动镜像，然后拷贝至sd卡进行启动，Petalinux则将这所有工作集中到一套sdk中，同时提供独立的qemu虚拟机便于测试应用程序能否在fpga板上正确运行。 Petalinux本身主要由两大部分组成： 一个配置、编译、开发工具包 (PetaLinux Tools) 一个Xilinx开发的Linux发行版 (Reference Linux Distribution) 接下来我们一一介绍这两个部分。 PetaLinux Tools (host)Petalinux Tools是一个大的“软件合集”，包括如Petalinux的cli，应用、驱动的模板，系统镜像打包工具，QEMU模拟器以及GCC工具链等等工具，提供从创建文件夹到在开发板运行系统的一条龙服务。开发人员可以使用这些工具来自定义引导加载程序，Linux内核或Linux应用程序。他们可以通过QEMU进行仿真，或网络和JTAG在物理硬件上运行系统内核，添加设备驱动程序，应用程序，库以及启动和测试软件。根据其功能，这些工具主要被分为三类，分别是： 自定义板机支持包生成工具：可以通过“Xilinx 硬件开发工具”导出的文件自动生成一个定制的Linux Board Support Package，其中包括内核和引导加载程序的配置，以及IP核驱动程序。 Linux配置工具：用于自定义引导加载程序，Linux内核，文件系统，库和系统参数的工具。与普通kernel的配置工具不同，这些配置工具将“完全知晓Xilinx硬件开发工具，并且可以读取自定义硬件有关的文件”。换句话说，这些工具能够配置一些fpga特有的功能，同时可以读取你开发的PL部分（如IP，或者什么其他的Verilog代码），并进行正确的配置（如获取正确的GPIO寄存器地址）。 软件开发工具:用于开发驱动程序、应用程序以及函数库。能够创建相应的工程模板，并能够编译、打包和分发软件组件（software components），使开发人员不需要过多关心编译相关的底层问题，并能够轻松的在开发板上安装和使用自己开发的程序。 Reference Linux DistributionPetaLinux提供一个完整的参考Linux发行版，该发行版已针对Xilinx的FPGA设备进行了集成和测试。这个发行版包含以下内容： Boot loader 优化过的kernel 基本的Linux软件和运行库 Debug工具 对多线程和FPU计算的支持 集成式web服务器 当然，你可以使用其他的Linux发行版作为rootfs，比如ubuntu minimal等等，但是一般来说使用Petalinux自带的参考Linux发行版就足够了。 自此，我们完整的介绍了Petalinux，所以Petalinux是什么？工具包+Linux发行版。 #3 安装Petalinux 参考：ug976: https://www.xilinx.com/support/documentation/sw_manuals/petalinux2013_10/ug976-petalinux-installation.pdf 大体上用户只需要执行安装包即可，但是Petalinux的安装脚本仅仅适配了REHL系发行版，这意味在其他发行版可能存在环境问题，需要我们手动配置环境。注意：请确保安装Petalinux的磁盘有至少50GiB的空闲容量，推荐至少有100GiB的空闲容量 step 1 下载安装包考虑到Petalinux的“安装包”实际上是一个“脚本”，并且在安装过程中需要进行解压操作，如果压缩部分出现少量错误，极有可能耗费数个小时但无功而返，因此请务必在下载完成后检查下载文件的hash值是否一致，若不一致还请重新下载。此外，请尽可能保证Petalinux和硬件开发工具的大版本号一致（如”2019.2”中的”2019”），以确保硬件描述文件等等是通用、可接受的。 step 2 配置运行环境参见ug976 11页表格，请根据你的发行版安装所需要的软件包。如果你使用的是Debian/Ubuntu发行版，那么可以尝试以下指令： 1sudo apt install tofrodos iproute gawk make net-tools libncurses5-dev tftpd zlib1g:i386 libssl-dev flex bison libselinux1 gnupg wget diffstat chrpath socat xterm autoconf libtool tar unzip texinfo zlib1g-dev gcc-multilib build-essential screen pax gzip 如果报错，请查看报错的软件包是否因为版本更新而改用其他名称。 step 3 安装执行petalinux-vxxxx.xx-final-installer.run，即你下载的安装包，它会默认安装至当前工作目录，即你执行安装包的目录。 安装过程需要解压缩，安装总耗时取决于磁盘性能，从半小时到数小时不等。 安装中途需要进行数次手动确认，因此请时不时看一下安装进度。 如果提示“tftp server”未运行，请暂时忽视，这并不会影响Petalinux的安装。 使用systemctl或者init.d启动tftp server即可，可能需要手动创建tftp用于收发文件的目录，根据错误提示手动创建目录即可。 运行安装包请勿使用root权限，如果报出权限错误，请检查该安装包是否未被赋予可执行权限。 step 4 验证安装安装完成后，进入安装目录。如果你是bash/zsh用户，请source setting.sh： 1$ source ./setting.sh 如果你还仍然坚持使用c shell，请source setting.csh: 1$ source ./setting.csh 你应该在终端上看见类似如下所示的输出： 123456PetaLinux environment set to ’/opt/petalinux-v2019.1-final’INFO: Finalising PetaLinux installationINFO: Checking free disk spaceINFO: Checking installed toolsINFO: Checking installed development librariesINFO: Checking network and other services 随后，请检查工作目录环境变量是否配置正确： 12$ echo $PETALINUX/opt/petalinux-v2019.1-final 该环境变量的值应该指向Petalinux的安装目录。","link":"/2020/05/30/petalinux-guide-1/"},{"title":"简易debug手册","text":"Debug手册 ddl是检验真理的唯一标准 单片机方面1.外部设变传输速率不够排查项目： 本地缓存加载速度 缓存发送逻辑 传输时钟频率 传输信号质量 电源稳定性 接受端芯片时钟频率 2.硬件错误排查项目： 栈内存分配是否冲足 指针是否正常（是否有野指针问题） 可以单步调试，查看出错前的PC寄存器 3.sdio错误排查项目 sdio外设时钟频率是否过快 SD卡槽是否接触不良，信号质量是否不好 SD卡初始化是否正常进行（断电再上电） 4.fatfs问题排查 目录不带最后一个’/‘ 未开启长文件名模式时的文件名长度限制 目录/文件名字符串结尾处的空字符是否存在","link":"/2017/12/25/debugger-1/"}],"tags":[{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"asc19","slug":"asc19","link":"/tags/asc19/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"ci","slug":"ci","link":"/tags/ci/"},{"name":"guide","slug":"guide","link":"/tags/guide/"},{"name":"stm32","slug":"stm32","link":"/tags/stm32/"},{"name":"fpga","slug":"fpga","link":"/tags/fpga/"}],"categories":[{"name":"ELSE","slug":"ELSE","link":"/categories/ELSE/"},{"name":"TRAV","slug":"TRAV","link":"/categories/TRAV/"},{"name":"TECH","slug":"TECH","link":"/categories/TECH/"}]}